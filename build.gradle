plugins {
    id 'java'
    alias(libs.plugins.run.paper)
    alias(libs.plugins.spotless)
}

group = 'org.bysenom'
version = '1.0-SNAPSHOT'

// Version aus CI-Umgebung übernehmen, wenn Tag-Pattern vX.Y.Z
if (System.getenv("GITHUB_REF_NAME") != null) {
    def ref = System.getenv("GITHUB_REF_NAME")
    if (ref ==~ /v\d+\.\d+\.\d+/) {
        version = ref.substring(1)
        println "CI detected tag ${ref}, setting version to ${version}"
    }
}

repositories {
    mavenCentral()
    maven {
        name = "papermc-repo"
        url = "https://repo.papermc.io/repository/maven-public/"
    }
}

dependencies {
    // Paper API über Version Catalog
    compileOnly libs.paper.api
    testImplementation libs.junit.jupiter
}

configurations.configureEach {
    resolutionStrategy {
        force libs.commons.lang3
    }
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(21)
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.release.set(21)
    options.compilerArgs += ['-Xlint:deprecation', '-Xlint:unchecked']
}

processResources {
    def props = [version: version]
    inputs.properties props
    filteringCharset 'UTF-8'
    filesMatching('plugin.yml') { expand props }
}

// Reproducible builds
jar {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
    manifest { attributes([
        'Implementation-Title': project.name,
        'Implementation-Version': project.version
    ]) }
}

test {
    useJUnitPlatform()
}

// Stellt sicher, dass die EULA akzeptiert ist bevor der Server startet
tasks.register('ensureEula') {
    doLast {
        def eulaFile = file('run/eula.txt')
        if (!eulaFile.exists()) {
            eulaFile.parentFile.mkdirs()
            eulaFile.text = 'eula=true\n'
            println '[ensureEula] eula.txt erzeugt (true)'
        } else if (!eulaFile.text.contains('eula=true')) {
            eulaFile.text = eulaFile.text.replaceAll(/eula=false/, 'eula=true')
            if (!eulaFile.text.contains('eula=true')) {
                eulaFile.append('\neula=true\n')
            }
            println '[ensureEula] eula.txt auf true gesetzt'
        } else {
            println '[ensureEula] EULA bereits akzeptiert.'
        }
    }
}

// Bereinigt blockierende Dateien im run/-Ordner (Session-Locks etc.)
tasks.register('unlockRunDir') {
    doLast {
        def lockFiles = [
                'run/world/session.lock',
                'run/world_nether/session.lock',
                'run/world_the_end/session.lock'
        ]
        lockFiles.each { p ->
            def f = file(p)
            if (f.exists()) {
                try {
                    if (f.delete()) {
                        println "[unlockRunDir] Gelöscht: ${p}"
                    } else {
                        println "[unlockRunDir] Konnte nicht löschen (evtl. gesperrt): ${p}"
                    }
                } catch (Exception e) {
                    println "[unlockRunDir] Fehler beim Löschen ${p}: ${e.message}"
                }
            }
        }
        // Optional: versuche latest.log zu rotieren, falls nicht gesperrt
        def latest = file('run/logs/latest.log')
        if (latest.exists()) {
            try {
                def backup = file("run/logs/latest-${System.currentTimeMillis()}.log")
                latest.renameTo(backup)
                println "[unlockRunDir] latest.log -> ${backup.name}"
            } catch (Exception ignored) {
                // wenn gesperrt, ignorieren – Paper kommt damit klar
            }
        }
    }
}

// Run-Paper mit Version aus Catalog ableiten
runServer {
    // libs.versions.paper ist ein String; extrahiere die MC-Version vor dem ersten '-'
    def mcVer = libs.versions.paper.get().split('-')[0]
    minecraftVersion(mcVer)
    runDirectory.set(file("run"))
    pluginJars.from(tasks.named('jar'))
    pluginJars.from(project(":lobby").layout.buildDirectory.file("libs/lobby-1.0-SNAPSHOT.jar"))
    dependsOn(tasks.named('ensureEula'))
    dependsOn(tasks.named('unlockRunDir'))
}

// ensure jars are built before runServer
tasks.named('runServer') {
    dependsOn(tasks.named('jar'))
    dependsOn(":lobby:build")
}

spotless {
    java {
        target 'src/**/*.java'
        importOrder()
        removeUnusedImports()
        endWithNewline()
    }
    format('misc') {
        target '*.md', '.editorconfig'
        trimTrailingWhitespace()
        endWithNewline()
    }
}

tasks.register('printVersion') {
    doLast {
        println "${project.name} version ${project.version}"
    }
}

// Zentrales Dist-Verzeichnis für alle JARs
def distDir = layout.projectDirectory.dir('dist')

tasks.register('collectJars', Copy) {
    // Stelle sicher, dass alle Subprojekte ihre JARs gebaut haben
    dependsOn(gradle.includedBuilds.collect { })
    dependsOn(subprojects.collect { it.tasks.named('jar') })
    // Quelle: alle build/libs der Subprojekte und das Root-Projekt
    from(layout.buildDirectory.dir('libs'))
    from(subprojects.collect { it.layout.buildDirectory.dir('libs') })
    into(distDir)
}

// Root-Build finalisiert: JARs einsammeln
tasks.named('build') { finalizedBy('collectJars') }

// Clean löscht zusätzlich das Dist-Verzeichnis
tasks.named('clean') { doLast { delete(distDir) } }
