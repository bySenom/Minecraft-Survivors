plugins {
    id 'java'
    alias(libs.plugins.run.paper)
    alias(libs.plugins.spotless)
}

group = 'org.bysenom'
version = '1.0-SNAPSHOT'

// Version aus CI-Umgebung übernehmen, wenn Tag-Pattern vX.Y.Z
if (System.getenv("GITHUB_REF_NAME") != null) {
    def ref = System.getenv("GITHUB_REF_NAME")
    if (ref ==~ /v\d+\.\d+\.\d+/) {
        version = ref.substring(1)
        println "CI detected tag ${ref}, setting version to ${version}"
    }
}

repositories {
    mavenCentral()
    maven {
        name = "papermc-repo"
        url = "https://repo.papermc.io/repository/maven-public/"
    }
}

dependencies {
    // Paper API über Version Catalog
    compileOnly libs.paper.api
    testImplementation libs.junit.jupiter
}

configurations.configureEach {
    resolutionStrategy {
        force libs.commons.lang3
    }
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(21)
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.release.set(21)
    options.compilerArgs += ['-Xlint:deprecation', '-Xlint:unchecked']
}

processResources {
    def props = [version: version]
    inputs.properties props
    filteringCharset 'UTF-8'
    filesMatching('plugin.yml') { expand props }
}

// Reproducible builds
jar {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
    manifest { attributes([
        'Implementation-Title': project.name,
        'Implementation-Version': project.version
    ]) }
}

test {
    useJUnitPlatform()
}

// Run-Paper mit Version aus Catalog ableiten
runServer {
    // libs.versions.paper ist ein String; extrahiere die MC-Version vor dem ersten '-'
    def mcVer = libs.versions.paper.get().split('-')[0]
    minecraftVersion(mcVer)
}

spotless {
    java {
        target 'src/**/*.java'
        importOrder()
        removeUnusedImports()
        endWithNewline()
    }
    format('misc') {
        target '*.md', '.editorconfig'
        trimTrailingWhitespace()
        endWithNewline()
    }
}

tasks.register('printVersion') {
    doLast {
        println "${project.name} version ${project.version}"
    }
}

// Zentrales Dist-Verzeichnis für alle JARs
def distDir = layout.projectDirectory.dir('dist')

tasks.register('collectJars', Copy) {
    // Stelle sicher, dass alle Subprojekte ihre JARs gebaut haben
    dependsOn(gradle.includedBuilds.collect { })
    dependsOn(subprojects.collect { it.tasks.named('jar') })
    // Quelle: alle build/libs der Subprojekte und das Root-Projekt
    from(layout.buildDirectory.dir('libs'))
    from(subprojects.collect { it.layout.buildDirectory.dir('libs') })
    into(distDir)
}

// Root-Build finalisiert: JARs einsammeln
tasks.named('build') { finalizedBy('collectJars') }

// Clean löscht zusätzlich das Dist-Verzeichnis
tasks.named('clean') { doLast { delete(distDir) } }
